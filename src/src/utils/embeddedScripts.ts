// ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by scripts/embed-lua.ts
// Generated at: 2026-02-17T13:35:36.340Z

export const LUA_SCRIPTS: Record<string, string> = {
  rate-limit: `local key = KEYS[1]
local timeWindow = tonumber(ARGV[1])
local max = tonumber(ARGV[2])
local continueExceeding = ARGV[3] == 'true'
local exponentialBackoff = ARGV[4] == 'true'
local MAX_SAFE_INTEGER = (2^53) - 1

local current = redis.call('INCR', key)

if current == 1 or (continueExceeding and current > max) then
  redis.call('PEXPIRE', key, timeWindow)
elseif exponentialBackoff and current > max then
  local backoffExponent = current - max - 1
  timeWindow = math.min(timeWindow * (2 ^ backoffExponent), MAX_SAFE_INTEGER)
  redis.call('PEXPIRE', key, timeWindow)
else
  timeWindow = redis.call('PTTL', key)
end

return {current, timeWindow}`,
  token-bucket: `local key = KEYS[1]
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local now = tonumber(ARGV[3])

local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
local tokens = tonumber(bucket[1])
local last_refill = tonumber(bucket[2])

if tokens == nil then
  tokens = limit
  last_refill = now
else
  local time_passed = now - last_refill
  local tokens_to_add = math.floor(time_passed / 1000) * (limit / window)
  tokens = math.min(limit, tokens + tokens_to_add)
  last_refill = now
end

local allowed = 0
if tokens >= 1 then
  tokens = tokens - 1
  allowed = 1
end

redis.call('HMSET', key, 'tokens', tokens, 'last_refill', last_refill)
redis.call('EXPIRE', key, window * 2)

return {allowed, math.floor(tokens), last_refill + (window * 1000)}`,
  sliding-window: `local key = KEYS[1]
local limit = tonumber(ARGV[1])
local window_start = tonumber(ARGV[2])
local now = tonumber(ARGV[3])
local window_ms = tonumber(ARGV[4])

redis.call('ZREMRANGEBYSCORE', key, 0, window_start)
local current = redis.call('ZCARD', key)

local allowed = 0
if current < limit then
  redis.call('ZADD', key, now, now)
  allowed = 1
  current = current + 1
end

redis.call('EXPIRE', key, math.ceil(window_ms / 1000))

local remaining = math.max(0, limit - current)
local reset_at = now + window_ms

return {allowed, remaining, reset_at}`,
  leaky-bucket: `local key = KEYS[1]
local capacity = tonumber(ARGV[1])
local leak_rate = tonumber(ARGV[2])
local now = tonumber(ARGV[3])

local bucket = redis.call('HMGET', key, 'water', 'last_leak')
local water = tonumber(bucket[1]) or 0
local last_leak = tonumber(bucket[2]) or now

local time_passed = (now - last_leak) / 1000
local leaked = time_passed * leak_rate
water = math.max(0, water - leaked)

local allowed = 0
if water < capacity then
  water = water + 1
  allowed = 1
end

redis.call('HMSET', key, 'water', water, 'last_leak', now)
redis.call('EXPIRE', key, capacity / leak_rate)

local remaining = math.floor(capacity - water)
local reset_at = now + ((water / leak_rate) * 1000)

return {allowed, remaining, reset_at}`,
};

export type ScriptName = "rate-limit" | "token-bucket" | "sliding-window" | "leaky-bucket";
